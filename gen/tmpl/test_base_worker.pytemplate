import asyncio
import json
from typing import Any, Type
from unittest.mock import AsyncMock

import pytest
from pydantic import BaseModel
from pydantic.dataclasses import dataclass
from yarl import URL

from common.base_workers.base_worker import BaseRabbitWorker, BatchWorker, Worker
from common.rabbitmq.tests.conftest import QueueInterface

pytestmark = pytest.mark.anyio


class ExampleMessage(BaseModel):
    """Класс сообщения для парсинга воркером."""

    field_a: int
    field_b: str


@dataclass
class ExampleCeleryMessage:
    """Класс сообщения для парсинга воркером."""

    field_a: int
    field_b: str


CeleryType = tuple[list[Any], dict[str, Any], dict[Any, Any]]  # noqa: WPS221


async def run_worker(worker: BaseRabbitWorker) -> None:
    """
    Запускает воркер на ограниченное время и проверяет, что он не упал.

    :param worker: воркер для запуска.
    """
    try:
        await asyncio.wait_for(worker.run(), timeout=0.3)
    except asyncio.TimeoutError:
        pass  # noqa: WPS420


async def test_process_valid_message(
    queue: QueueInterface,
    rabbit_url: URL,
    routing_key: str,
    exchange_name: str,
) -> None:
    """Проверяем, что воркер обрабатывает корректное сообщение."""
    message = ExampleMessage(field_a=1, field_b="test")
    await queue.publish_message(message.model_dump_json())
    mock = AsyncMock()
    worker = Worker(
        message_class=ExampleMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        clients_state_class=None,
    )

    await run_worker(worker)

    assert await queue.is_empty()
    mock.assert_awaited_once_with(message, None)


@pytest.mark.parametrize(
    "celery_message",
    [
        [[1, "test"], {}, {}],
        [[1], {"field_b": "test"}, {}],
        [[], {"field_a": 1, "field_b": "test"}, {}],
    ],
)
async def test_process_valid_celery_message(
    queue: QueueInterface,
    rabbit_url: URL,
    celery_message: CeleryType,
    routing_key: str,
    exchange_name: str,
) -> None:
    """Проверяем, что воркер обрабатывает корректное celery сообщение."""
    await queue.publish_message(json.dumps(celery_message))
    mock = AsyncMock()
    worker = Worker(
        message_class=ExampleCeleryMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=True,
        clients_state_class=None,
    )
    expected_message = ExampleCeleryMessage(field_a=1, field_b="test")

    await run_worker(worker)

    assert await queue.is_empty()
    mock.assert_awaited_once_with(expected_message, None)


@pytest.mark.parametrize("worker_cls", [Worker, BatchWorker])
async def test_process_invalid_message(
    queue: QueueInterface,
    rabbit_url: URL,
    worker_cls: Type[BaseRabbitWorker],
    routing_key: str,
    exchange_name: str,
) -> None:
    """
    Проверяем, что воркер обрабатывает сообщение неправильного формата.

    Сообщения должны быть удалены из очереди.
    """
    await queue.publish_message("{i am not a good json}")
    await queue.publish_message('{"i_am_a_good":"json"}')
    mock = AsyncMock()
    extra_init_params: dict[str, int] = {}
    if worker_cls == BatchWorker:
        extra_init_params = {
            "batch_size": 10,
            "batch_timeout": 0.1,
        }
    worker = worker_cls(  # type: ignore
        message_class=ExampleMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        clients_state_class=None,
        **extra_init_params,
    )

    await run_worker(worker)

    assert await queue.is_empty()
    mock.assert_not_awaited()


@pytest.mark.parametrize("worker_cls", [Worker, BatchWorker])
async def test_process_callback_exception(
    queue: QueueInterface,
    rabbit_url: URL,
    worker_cls: Type[BaseRabbitWorker],
    routing_key: str,
    exchange_name: str,
) -> None:
    """
    Проверяем, что воркер обрабатывает исключение внутри колбэка.

    Сообщение должно вернуться в очередь.
    """
    message = ExampleMessage(field_a=1, field_b="test")
    await queue.publish_message(message.model_dump_json())
    mock = AsyncMock(side_effect=Exception())
    extra_init_params: dict[str, int] = {}
    if worker_cls == BatchWorker:
        extra_init_params = {
            "batch_size": 10,
            "batch_timeout": 0.1,
        }
    worker = worker_cls(  # type: ignore
        message_class=ExampleMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        clients_state_class=None,
        **extra_init_params,
    )

    await run_worker(worker)

    mock.assert_awaited()
    incoming_message = await queue.get_message()
    assert json.loads(incoming_message.body) == message.model_dump()  # type: ignore


@pytest.mark.parametrize("worker_cls", [Worker, BatchWorker])
async def test_process_empty_queue(
    queue: QueueInterface,
    rabbit_url: URL,
    worker_cls: Type[BaseRabbitWorker],
    routing_key: str,
    exchange_name: str,
) -> None:
    """Проверка, что воркер не падает при пустой очереди."""
    mock = AsyncMock(side_effect=Exception())
    extra_init_params: dict[str, int] = {}
    if worker_cls == BatchWorker:
        extra_init_params = {
            "batch_size": 10,
            "batch_timeout": 0.1,
        }
    worker = worker_cls(  # type: ignore
        message_class=ExampleMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        clients_state_class=None,
        **extra_init_params,
    )

    await run_worker(worker)

    assert await queue.is_empty()
    mock.assert_not_awaited()


async def test_worker_proceed_all_messages(
    queue: QueueInterface,
    rabbit_url: URL,
    routing_key: str,
    exchange_name: str,
) -> None:
    """
    Проверяем работу при отправке нескольких сообщений.

    Сообщение 1: валидное, падает на запросе к внешнему сервису, обратно в очередь
    Сообщение 2: валидное, сохраняется
    Сообщение 3: невалидное, убирается из очереди
    Сообщение 4: валидное, сохраняется

    Требования:
    1) Воркер должен обработать ВСЕ сообщения
    2) В очереди должно остаться только Сообщение 1
    3) В "базу" (мок) должны записаться два сообщения (2 и 4)
    4) Сообщение 3 должно исчезнуть.
    """
    fatal_message = ExampleMessage(field_a=1, field_b="db fail")
    message = ExampleMessage(field_a=0, field_b="ok")

    await queue.publish_message(fatal_message.model_dump_json())
    await queue.publish_message(message.model_dump_json())
    await queue.publish_message("{i am not a good json}")
    await queue.publish_message(message.model_dump_json())

    dbmock = AsyncMock()

    async def mock_func(message: ExampleMessage, clients: None) -> None:  # noqa: WPS430
        """Функция для симуляции ошибки в колбэке."""  # noqa: DAR401
        if message.field_a != 0:
            raise Exception()  # noqa: WPS454
        await dbmock()

    worker = Worker(  # type: ignore
        message_class=ExampleMessage,
        callback=mock_func,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=2,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        clients_state_class=None,
    )
    await run_worker(worker)

    assert dbmock.await_count == 2
    incoming_message = await queue.get_message()
    assert json.loads(incoming_message.body) == fatal_message.model_dump()
    assert await queue.is_empty()


async def test_batch_worker_process_valid_messages(
    queue: QueueInterface,
    rabbit_url: URL,
    routing_key: str,
    exchange_name: str,
) -> None:
    """Проверяем, что воркер обрабатывает корректное сообщение."""
    messages = [
        ExampleMessage(field_a=1, field_b="test1"),
        ExampleMessage(field_a=2, field_b="test2"),
    ]
    for message in messages:
        await queue.publish_message(message.model_dump_json())
    mock = AsyncMock()
    worker = BatchWorker(  # type: ignore
        message_class=ExampleMessage,
        callback=mock,
        queue_name=queue.name,
        routing_key=routing_key,
        exchange_name=exchange_name,
        broker_url=rabbit_url,
        prefetch_count=100,
        metrics_host="",
        metrics_port=0,
        health_host="",
        health_port=0,
        enable_health_check=False,
        is_queue_durable=False,
        is_exchange_durable=False,
        is_vector=False,
        batch_timeout=0.1,
        batch_size=10,
        clients_state_class=None,
    )

    await run_worker(worker)

    assert await queue.is_empty()
    mock.assert_awaited_once_with(messages, None)
