from pathlib import Path
{%- if return_type != 'none' %}

from pydantic import BaseModel, TypeAdapter
{%- endif %}

from common.{{client}}.base_{{client}}_queries import Base{{client.split('_')|map('capitalize')|join}}Query

SQL_{{filename|upper}} = (
    Path(__file__)
    .parent.parent.joinpath(
        "sql/{{filename}}.sql",
    )
    .read_text()
)

{% if return_type != 'none' %}
class {{filename.split('_')|map('capitalize')|join}}Result(BaseModel):
    """TODO:Заменить_описание."""

{% endif %}
class {{filename.split('_')|map('capitalize')|join}}DbQuery(Base{{client.split('_')|map('capitalize')|join}}Query):
    """TODO:Заменить_описание."""

    async def __call__(
        self,
    {%- if return_type == 'fetchone' %}
    ) -> {{filename.split('_')|map('capitalize')|join}}Result:
    {%- elif return_type == 'fetchall' %}
    ) -> list[{{filename.split('_')|map('capitalize')|join}}Result]:
    {%- else %}
    ) -> None:
    {%- endif %}
        """
        TODO:Заменить_описание.

        :return: SQL Result
        """
        query_params = {}
        query = SQL_{{filename|upper}} % query_params
        self.query_log.info(f"Сформирован SQL запрос SQL_{{filename|upper}}:\n{query}")
        async with self.cursor() as cursor:
            await cursor.execute(SQL_{{filename|upper}}, query_params)
    {%- if return_type == 'fetchone' %}
            raw_result = await cursor.fetchone()
        return TypeAdapter({{filename.split('_')|map('capitalize')|join}}Result).validate_python(raw_result)
    {%- elif return_type == 'fetchall' %}
            raw_result = await cursor.fetchall()
        return TypeAdapter(list[{{filename.split('_')|map('capitalize')|join}}Result]).validate_python(raw_result)
    {%- else %}
        return None
    {%- endif %}
